
**상속 Inheritance —(extends )**

- extends 사용  `class ColorPoint extends Point { }`
- 자식클래스가 부모클래스를 물려 받음 부모클래스의 기능을 확장 하는 개념
- Object 클래스를 자동으로 상속 받음
- 다중 상속 불가능 (인터페이스는 가능)

**오버라이딩 Overriding — (재정의)**

- ***@Override 표기 권장***
- **상속 관계**의 자식클래스가
  같은 이름  / 같은 매개변수인
  부모클래스의 메서드를 자식 클래스에서 재정의 하는 것
- 접근제한자는 같거나 제한이 없어야 한다 (public)
- 다형성 실현
- 런타임 시 결정

**오버로딩 Overloading  — (중복작성)**

- **같은 클래스 내**에 있는 클래스에
  같은 이름 / 다른 매개변수인 (타입, 개수)
  여러 개의 메소드가 같은 이름으로 있는 것
- 다형성 실현
- 컴파일 시 결정

**this — (this. or this())**

- 객체 자기 자신에 대한 레퍼런스, 컴파일러에 의해 자동 관리 (첫줄에 와야함)
- **this.  :**  동일 클래스 내의 멤버변수, 메서드 참조 가능
- **this() :** 생성자 내부에서 자신의 다른 생성자 호출가능

**super — (super. or super())**

- 한단계 위 부모클래스의 객체를 지정할 때 사용하는 키워드 (첫줄에 와야함)
- **super.  :**  부모클래스 멤버 참조 가능
- **super() :** 생성자 내부에서만 사용, 부모클래스 생성자 호출

**this() , super()**

1. 생성자에서만 사용됨!
2. 반드시 같은 클래스의 다른 생성자!!를 호출할 때 사용
3. 반드시 생성자의 첫 문장!!으로 사용되어야함

### 상속 필요성
클래스 중복 작성 제거 간결화
클래스 계층별 관리 용이
클래스 재사용/확장을 통한 생산성 향상

### 상속 - extends 키워드
`class ColorPoint extends Point { }`

서브 클래스에서 슈퍼클래스 접근 가능(private멤버 제외)

### 상속 특징
다중 상속 지원 XX (인터페이스는 가능)
ogject 클래스를 자동으로 상속 받는다. 유일하게 슈퍼클래스를 가지지 않는 클래스.

### 슈퍼/서브 클래스의 생성자
호출은 서브클래스가 먼저, 실행은 슈퍼클래스 생성자가 먼저
슈퍼/서브 생성자 둘다 실행됨

### 슈퍼/서브 클래스의 생성자 선택 (묵시적
서브클래스의 생성자가 슈퍼 클래스 생성자로 기본 생성자 선택됨 (by 자바컴파일러)

### 슈퍼/서브 클래스의 생성자 선택 (명시적
super() : 슈퍼클래스 생성자의 호출 (첫줄에 와야함)
캐스팅
타입변환
업캐스팅
서브클래스 -> 슈퍼클래스 타입으로 변환되는 것
슈퍼클래스 레퍼런스가 서브 클래스 객체를 가리키도록 치환하는 것
Person p;
Student s = new Student();
p = s;

### 슈퍼클래스의 멤버만 접근 가능
속성이 잠깐 가려져있음, 다운캐스팅시 복구 가능
명시적타입변환을 하지않아도된다. p =(Person) s;

### 다운캐스팅
업캐스팅 된 것을 원래대로 되돌리는 것
Person p = new Student();

명시적타입변환 필수 !! Student s = (Student)p;

### instanceof 연산자 (이항 연산자)
객체의 진짜 클래스 타입 구분을 위한 연산자
객체레퍼런스 instanceof 클래스타입 ⇒ T or F 로 반환
메서드 오버라이딩
슈퍼클래스에 선언된 메소드를 중복 작성하여 슈퍼클래스 메소드를 무력화

### @Override 표기
항상 서브클래스의 오버라이딩한 메소드가 실행됨
이름, 리턴타입, 매개변수리스트 모두 같도록 작성

### 오버라이딩 목적 (다형성 실현)

하나의 인터페이스에 서로 다른 내용 구현

### 동적 바인딩
실행할 메소드를 컴파일시 결정하지 않고 runtime 실행시 결정하는 것
오버라이딩 된 메소드가 항상실행!! 되도록 보장한다.
정적 바인딩 - super 키워드
super 키워드를 이용해서 슈퍼 클래스 멤버에 접근 가능.
오버로딩 / 오버라이딩
오버로딩 - 한 클래스/상속 관계에 있는 클래스에 매개변수 타입-개수가 다른 여러개의 메소드가 같은 이름으로 있는 것 ( 중복 작성)
오버라이딩 - 슈퍼클래스의 메소드(이름,타입등)를 동일하게 서브클래스에 가져와 재정의한 것 (재작성)
추상 메소드 (= 밑그림)
abstract 키워드 + 원형만 선언 (메소드의 헤더만)
추상 클래스

추상 메소드를 최소 한개 가지고 abstract 로 선언된 클래스 → 무조건 추상 클래스로 선언되어야한다.
추상 메소드가 없어도 abstract 로 선언된 클래스


추상 클래스의 인스턴스(객체) 생성 불가 → 컴파일 오류

## 추상클래스 상속

추상 클래스(추상메소드 보유)를 상속 받으면
서브클래스는 자동으로 추상 클래스 (추상메소드를 받기때문)
즉 , 서브클래스에 abstract 를 명시해야함

## 추상 클래스 구현 (= 본체 만들기)

서브에서 슈퍼의 모든 추상 메소드를 오버라이딩 하여 실행 가능한 코드로 구현하는 것
서브가 추상 클래스를 구현했다면, 인스턴스를 만들 수 있다.

## 추상클래스 목적 (서브클래스 다형성 실현)

상속을 위한 슈퍼클래스로 활용하기 위한 것 → 서브가 상속할 클래스 원형(밑그림)을 제공

## 인터페이스 - interface 키워드
서로 다른 하드웨어 장치들이 상호 데이터를 주고 받을 수 있는 규격
클래스를 선언하듯이 선언한다.

필드(멤버 변수)를 만들 수 없음
객체를 생성할 수 없다 → 오류

## 인터페이스 멤버 5종류

상수
추상메소드 (public abstract 생략 가능, 헷갈리지않게 주의!)
default 메소드 (public 생략 가능)
private 메소드
static 메소드

## 인터페이스 상속 - extends 키워드

다른 인터페이스를 상속 할수 있다.
다중 상속 가능 (, 콤마로 연결)

## 인터페이스 구현 - impliments 키워드

인터페이스의 모든 추상 메소드를 구현한 클래스를 작성하는 것

