
캡슐화
객체를 캡슐로 싸서 내부 보호, 외부 접근으로부터 안전
클래스 → 인스턴스 클래스 (필드, 메소드)
객체 = 클래스의 인스턴스

상속
자식클래스가 부모클래스를 물려 받음 부모클래스의 기능을 확장 하는 개념
부모클래스 = 슈퍼클래스
자식클래스 = 서브클래스

다형성
메소드가 클래스/객체에 따라 다르게 구현되는 것
메소드 오버라이딩 :
메소드 오버로딩 :

## 객체 지향 프로그래밍
현실세계를 모델링하기 위해 객체 개념을 사용
* 캡슐화
* 상속
* 다형성
* 추상화

## 객체지향 설계 원칙 (SOLID)
* Single Responsibility Principle (단일 책임 원칙): 클래스는 하나의 책임만 가져야 한다.
* Open/Closed Principle (개방-폐쇄 원칙): 기존 코드는 수정하지 않고 확장 가능해야 한다.
* Liskov Substitution Principle (리스코프 치환 원칙): 부모 클래스는 자식 클래스로 대체 가능해야 한다.
* Interface Segregation Principle (인터페이스 분리 원칙): 필요한 메서드만 포함한 인터페이스를 사용.
* Dependency Inversion Principle (의존 역전 원칙): 고수준 모듈은 저수준 모듈에 의존하지 않아야 한다.

## 접근제어자

**클래스 — class**

- 객체의 설계도, 틀 (데이터, 함수를 포함한 사용자 정의 데이터 타입)
- 속성(필드) 와 메소드로 이루어져있다.

```java
public class Person {
    private String name;
    private int age;

    // 메소드 (행동)
    public void displayInfo() {
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
```

**객체 생성 방법**

1. 객체에 대한 레퍼런스 변수 선언
   `Circle pizza;`
2. 객체 생성 (new 연산자)
   `pizza = new Circle();`

1+2. 선언 + 객체 동시에 하기
`Circle pizza = new Circle();`

1. 접근 (. 점 연산자 )
   `pizza.name = "피자";`

**지역 변수**

- 메서드 안에서 선언된 변수
- 반드시 초기화를 해야한다.

**멤버 변수 (필드)**

- 클래스 내부에 선언된 변수
- 객체의 상태를 나타낸다.
- 객체 생성 시 각 테이터 타입에 맞게 자동 초기화 된다.

**참조 변수**

- 객체를 가리키는 변수 , 객체의 메모리 주소 저장
- `MyClass obj = new MyClass();`

**멤버 함수 (메소드)**

- 클래스 내부에 정의된 함수
- 객체의 행동을 나타낸다.

**메서드 method**

- 클래스 내부에 정의 된 함수, 객체의 행위 (Behavior) 정의
- 메서드는 객체 지향의 핵심 요소  = 캡슐화 / 재사용성 / 모듈화 / 추상화

**메서드 선언 방법**

- 클래스 내부에 정의

```java
접근제어자 반환타입 메서드이름 (매개변수){
		//본체
}

public int add(int a, int b) {
    // 메소드 본체
}
```

**생성자  — (new)**

- 객체가 생성될 떄 초기화를 위해 실행되는 메서드
- 클래스 이름과 동일해야한다.
- 리턴 타입 지정 불가능하다.
- 객체 생성 시 한번만 호출된다.
- 여러 개 작성 가능하다. —-(생성자 오버로딩)

**기본생성자 = 디폴트생성자**

- 매개변수가 없는 단순 리턴 생성자이다.
- 클래스에 생성자가 하나도 없으면 (컴파일오류)
  JVM이 자동으로 생성 해줌
- 생성자가 하나라도 존재하면 자동 생성 안됨

**매개변수 parameter**

- 메소드가 호출될 때 전달되는 값을 받기 위해 사용되는 변수
- 메소드가 실행될 때 해당 값이 할당됨

**반환 유형 return type**

- 메소드가 실행이 완료되면 호출자에게 돌려주는 값의 데이터 타입
- 기본 데이터 타입 - int, double, char, boolean 등
- 참조 데이터 타입 - 객체, 배열, 클래스 등
- void - 값 반환 하지 않음

**return**

- 값의 반환
- 메서드 종료 (void형 메서드에서)

**기본 타입  primitive type**

- 정수, 실수, 문자, 논리 값을 저장하는 데이터 타입
- 실제 값(value) 저장

**참조 타입  reference type**

- 배열, 클래스, 인터페이스 타입
- 메모리의 주소값 저장
- 스택(stack)영역에 주소값을 저장하고 내부의 실제 값은 힙(heap) 영역에 저장

**가비지**

- 할당 받은 객체, 배열 메모리 중 더이상 사용하지 않게된 메모리
- 참조하는 레퍼런스가 하나도 없는 객체 / 배열을 가비지로 판단함

**가비지 컬렉션 (by 가비지 컬렉션 스레드)**

- 가비지가 많아지면 가용 메모리 양이 줄어듬, 일정 크기 이하로 줄어들면 JVM 이 자동으로 가비지 회수해서 가용메모리를 늘려줌
- System.gc(); //가비지 컬렉션 요청

**패키지 package  — (import)**

- import 사용  `import 패키지.*;`
- 서로 관련 있는 클래스를 하나의 디렉터리에 모아 놓은 것
- 자바 소스 파일 첫 줄에 와야 한다.
- 클래스 파일은 패키지에 소속 되어야 한다.
- 대분류와 소분류 패키지를 구분할 때는 .(dot)을 사용
- 소문자 권장, 키워드나 java로 시작 불가능

**object 클래스 —(java.lang)**

- 모든 클래스는 강제로 object 를 상속 받는다.
- object 만이 아무 클래스도 상속 받지 않는 최상위 클래스

----
**캡슐화**

객체를 캡슐로 싸서 내부 보호, 외부 접근으로부터 안전

클래스 → 인스턴스 클래스 (필드, 메소드)

객체 = 클래스의 인스턴스

**상속**

자식클래스가 부모클래스를 물려 받음 부모클래스의 기능을 확장 하는 개념

부모클래스 = 슈퍼클래스

자식클래스 = 서브클래스

**다형성**

메소드가 클래스/객체에 따라 다르게 구현되는 것

메소드 오버라이딩 :

메소드 오버로딩 :

**클래스생성**

접근지정자 , 클래스 선언, 클래스 이름, 멤버 = 클래스 구성요소 (필드, 메소드)

**객체생성**

1\. 객체에 대한 레퍼런스 변수 선언 

Circle pizza;

2\. 객체 생성  (new 연산자)

pizza = new Circle();

\- 선언 + 객체 동시에 하기

Circle pizza = new Circle();

3\. 접근 (. 점 연산자 )

pizza.name = "피자";

**생성자**

객체가 생성될 떄 초기화를 위해 실행되는 메서드

1\. 생성자는 클래스 이름과 동일 (필수)

2\. 생성자 여러개 작성 가능

3\. 생성자는 객체를 생성할 때 한번만 호출 됨

4\. 생성자에 리턴타입 지정 불가능 XX

5\. 생성자의 목적은 객체 생성을 위한 초기작업임

**기본생성자 = 디폴트 생성자**

매개변수 X , 단순 리턴 생성자

\- 클래스에 생성자가 하나도 없으면 (컴파일오류)

컴파일러가 자동으로 생성 해줌

\- 생성자가 하나라도 존재하면 자동 생성 안됨 

**this 레퍼런스**

객체 자기 자신에 대한 레퍼런스, 컴파일러에 의해 자동 관리

\- 다른 생성자 호출가능 this()

1\. 생성자에서만 사용됨!

2\. 반드시 같은 클래스의 다른 생성자!!를 호출할 때 사용

3\. 반드시 생성자의 첫문장!!으로 사용되어야함

**객체 배열**

객체 레퍼런스를 원소로 갖는 배열

1\. 레퍼런스 선언 (크기 설정 X)

Circle \[\] c;

2\. 레퍼런스 배열 생성

c = new Circle\[5\];

3\. 객체 생성

for (int = i ; i<c.length; i++)

c\[i\] = new Circle(i);

**배열 원소 개체 접근 **(인덱스)****

c\[i\] 

**메소드 형식**

접근지정자 , 리턴타입

**인자 전달 = 값에 의한 호출**

1\. 기본 타입 값 전달

기본 타입 => 복사 되어 전달

2\. 객체 전달

클래스 타입 => 객체의 레퍼런스값 전달

3\. 배열 전달

배열 => 배열에 대한 레퍼런스 전달

### **메소드 오버로딩 = 메소드 중복**

이름 같지만 , 매개변수 타입-개수가 다른 메소드들

1.  이름이 동일해야함
2.  매개변수 개수-타입이 서로 달라야함

### **객체 치환**

객체 복사가 아님 X

ob1= ob2

ob1 의 객체는 아무도 가리키지 않음 접근 불가 상태 가비지가 되어 자동으로 수거돼 재사용됨.

### **객체 소멸**

객체 소멸 시키는 연산자는 없다 / 개발자 마음대로 객체 소멸 불가능

### **가비지**

할당 받은 객체, 배열 메모리 중 더이상 사용하지 않게된 메모리

참조하는 레퍼런스가 하나도 없는 객체 / 배열을 가비지로 판단함

### **가비지 컬렉션 (by 가비지 컬렉션 스레드)**

가비지가 많아지면 가용 메모리 양이 줄어듬, 일정 크기 이하로 줄어들면 JVM 이 가비지 회수해서 가용메모리를 늘려줌

System.gc(); //가비지 컬렉션 요청

### **접근지정자**

1.  private
2.  protected
3.  public
4.  생략 (디폴트 접근 지정)

### **클래스 접근 지정**

1.  public
2.  default

### **멤버 접근 지정**

private(클래스 내) < default (동일 패키지 내)< protected < public

-   protected

1.  같은 패키지 내의 모든 클래스
2.  다른 패키지라도 자식 클래스의 경우 접근 허용

### **static 멤버 = 클래스 멤버**

static 지시어로 선언된 멤버

\-독립적인 공간 할당 받음

\-클래스당 하나만 생성됨

\-객체 공간 할당 전 이미 외부에 별도로 존재함 (프로그램 시작 / 클래스 로딩 시 생성)

\-객체 소멸해도 공간 차지 → 프로그램 종료시 소멸됨

\-동일한 클래스 모든 객체들에 의해 공유됨. (클래스 이름 / 객체 이름으로 활용 가능)

static int m; ⇒ StaticSample.m = 3

1.전역변수/ 전역함수 만들 때 활용

2.공유멤버 만들 때 활용

1.static멤버만 static메소드에 접근 가능

2.static멤버를 인스턴스 멤버는 사용할 수 있다.

3.static메소드에는 this 를 사용 불가

### **final 키워드**

1.  final 클래스 : 상속 X
2.  final 메소드 : 오버라이딩 X
3.  final 필드 : 상수화
