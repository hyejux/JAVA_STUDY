


---
## Inheritance 

**상속 Inheritance —(extends )**

- extends 사용  `class ColorPoint extends Point { }`
- 자식클래스가 부모클래스를 물려 받음 부모클래스의 기능을 확장 하는 개념
- Object 클래스를 자동으로 상속 받음
- 다중 상속 불가능 (인터페이스는 가능)

### 상속 필요성
* 클래스 중복 작성 제거 간결화
* 클래스 계층별 관리 용이
* 클래스 재사용/확장을 통한 생산성 향상

### 상속 - extends 키워드
`class ColorPoint extends Point { }`

서브 클래스에서 슈퍼클래스 접근 가능 (private멤버 제외)

### 상속 특징
* 다중 상속 지원 XX (인터페이스는 다중 상속 가능)
* object 클래스를 자동으로 상속 받는다. -> 유일하게 슈퍼클래스를 가지지 않는 클래스.

---

## Overriding

**오버라이딩 Overriding — (재정의)**

- ***@Override 표기 권장***
- **상속 관계**의 자식클래스가
  같은 이름  / 같은 매개변수인
  부모클래스의 메서드를 자식 클래스에서 재정의 하는 것
- 접근제한자는 같거나 제한이 없어야 한다 (public)
- 다형성 실현
- 런타임 시 결정

---

## Overloading

**오버로딩 Overloading  — (중복작성)**

- **같은 클래스 내**에 있는 클래스에
  같은 이름 / 다른 매개변수인 (타입, 개수)
  여러 개의 메소드가 같은 이름으로 있는 것
- 다형성 실현
- 컴파일 시 결정

---
## Abstract & Interface


## Abstract 
상속을 통해 공통 기능을 확장할 때
1. abstract 키워드를 사용하여 선언한 클래스
2. 객체를 직접 생성할 수 없음 (인스턴스화 불가능)
3. 일반 메서드 + 추상 메서드(구현이 없는 메서드) 포함 가능
4. 상속을 통해 기능 확장 가능 (extends 사용)


#### 추상 메소드 (= 밑그림)
abstract 키워드 + 원형만 선언 (메소드의 헤더만)

#### 추상 클래스
* 추상 메소드를 최소 한개 가지고 abstract 로 선언된 클래스 → 무조건 추상 클래스로 선언되어야한다.
* 추상 메소드가 없어도 abstract 로 선언된 클래스
* 추상 클래스의 인스턴스(객체) 생성 불가 → 컴파일 오류

#### 추상클래스 상속
* 추상 클래스(추상메소드 보유)를 상속 받으면, 서브클래스는 자동으로 추상 클래스 (추상메소드를 받기때문)
* 즉, 서브클래스에 abstract 를 명시해야함

#### 추상 클래스 구현 ( = 본체 만들기)
* 서브에서 슈퍼의 모든 추상 메소드를 `오버라이딩` 하여 실행 가능한 코드로 구현하는 것
* 서브가 추상 클래스를 구현했다면, 인스턴스를 만들 수 있다.

#### 추상클래스 목적 (서브클래스 다형성 실현)
상속을 위한 슈퍼클래스로 활용하기 위한 것 → 서브가 상속할 클래스 원형(밑그림)을 제공


## Interface 
다형성을 제공, 여러 클래스에 공통된 기능을 부여할 때

1. 완전한 추상화를 제공 (100% 추상 메서드만 가짐, Java 8 이후 디폴트 메서드 가능)
2. 모든 메서드는 기본적으로 public abstract
3. 필드는 자동으로 public static final (상수)
4. 다중 구현 가능 (implements 사용)

#### 인터페이스 - interface 키워드
* 서로 다른 하드웨어 장치들이 상호 데이터를 주고 받을 수 있는 규격
* 클래스를 선언하듯이 선언한다.

- 필드(멤버 변수)를 만들 수 없음
- 객체를 생성할 수 없다 → 오류

####  인터페이스 멤버 5종류

- 상수 : 모든 필드는 암시적으로 public static final
- 추상메소드 (public abstract 생략 가능, 헷갈리지않게 주의!) :모든 메소드는 암시적으로 public abstract로 선언
- default 메소드 (public 생략 가능) :  필요에 따라 오버라이딩
- private 메소드
- static 메소드
- 생성자가 없음

#### 인터페이스 상속 - extends 키워드
* 다른 인터페이스를 상속 할수 있다.
* 다중 상속 가능 (, 콤마로 연결)

#### 인터페이스 구현 - impliments 키워드
* 인터페이스의 `모든 추상 메소드`를 구현한 클래스를 작성하는 것
* 다중 구현 가능



--- 
## Object Class (java.lang)

**object 클래스 —(java.lang)**

- 모든 클래스는 강제로 object 를 상속 받는다.
- object 만이 아무 클래스도 상속 받지 않는 최상위 클래스



### hashCode()

객체의 해시 코드 ( 고유한 정수값) 제공

### toString() —- 객체 → 문자열 변환

‘객체+문자열’ 연산 or 객체 출력시 자동 출력됨.

```
public string toString(); // 오버라이딩 가능
a + "점" // a.toString() + "점"
```

### getClass() / getName()

객체의 클래스 정보를 담은 class 객체 리턴

객체의 클래스명 알아냄

### equals() —- 객체 비교

두 레퍼런스 값을 비교

```
public boolean equals(Object obj) // 객체의 내용 비교
```

### Wrapper 클래스

-   8개의 기본타입을 객체로 다루기 위한 클래스
-   Byte / Short / Integer/ Long /Character/Float /Double / Boolean

```
Integer i = Integer.valueOf(10) // 정수 10 객체화
```

-   Character 제외한 나머지는 문자열로 Wp객체 생성 가능
-   주요 메소드 대부분 static 타입

```
//기본타입 값 알아내기
Integer i = Integer.valueOf(10); // 정수 10 객체화
int ii = i.intValue();
```

```
//문자열을 기본타입으로 변환
int i = Integer.parseInt("123"); // 정수 10 객체화
double d = Double.parseDouble("3.141592");
```

```
//기본타입을 문자열로 변환
String s1 = Integer.toString(123); //"123"
```

### boxing / unboxing

-   박싱 : 기본타입 → Wrapper 객체
-   언박싱 : Wrapper 객체 → 기본타입
-   jdk 1.5 부터는 자동박싱/언박싱

```
Integer ten =10; // 자동 박싱 Integer ten = Integer.valueOf(10);
int n = ten; // 자동 언박싱 int n = ten.intValue();
```

### 슈퍼/서브 클래스의 생성자
호출은 서브클래스가 먼저, 실행은 슈퍼클래스 생성자가 먼저
슈퍼/서브 생성자 둘다 실행됨

### 슈퍼/서브 클래스의 생성자 선택 (묵시적
서브클래스의 생성자가 슈퍼 클래스 생성자로 기본 생성자 선택됨 (by 자바컴파일러)

### 슈퍼/서브 클래스의 생성자 선택 (명시적
super() : 슈퍼클래스 생성자의 호출 (첫줄에 와야함)
캐스팅
타입변환
업캐스팅
서브클래스 -> 슈퍼클래스 타입으로 변환되는 것
슈퍼클래스 레퍼런스가 서브 클래스 객체를 가리키도록 치환하는 것
Person p;
Student s = new Student();
p = s;

### 슈퍼클래스의 멤버만 접근 가능
속성이 잠깐 가려져있음, 다운캐스팅시 복구 가능
명시적타입변환을 하지않아도된다. p =(Person) s;

### 다운캐스팅
업캐스팅 된 것을 원래대로 되돌리는 것
Person p = new Student();

명시적타입변환 필수 !! Student s = (Student)p;

### instanceof 연산자 (이항 연산자)
객체의 진짜 클래스 타입 구분을 위한 연산자
객체레퍼런스 instanceof 클래스타입 ⇒ T or F 로 반환
메서드 오버라이딩
슈퍼클래스에 선언된 메소드를 중복 작성하여 슈퍼클래스 메소드를 무력화

### @Override 표기
항상 서브클래스의 오버라이딩한 메소드가 실행됨
이름, 리턴타입, 매개변수리스트 모두 같도록 작성

### 오버라이딩 목적 (다형성 실현)
하나의 인터페이스에 서로 다른 내용 구현

### 동적 바인딩
실행할 메소드를 컴파일시 결정하지 않고 runtime 실행시 결정하는 것
오버라이딩 된 메소드가 항상실행!! 되도록 보장한다.

### 정적 바인딩 - super 키워드
super 키워드를 이용해서 슈퍼 클래스 멤버에 접근 가능.
오버로딩 / 오버라이딩
오버로딩 - 한 클래스/상속 관계에 있는 클래스에 매개변수 타입-개수가 다른 여러개의 메소드가 같은 이름으로 있는 것 ( 중복 작성)
오버라이딩 - 슈퍼클래스의 메소드(이름,타입등)를 동일하게 서브클래스에 가져와 재정의한 것 (재작성)






